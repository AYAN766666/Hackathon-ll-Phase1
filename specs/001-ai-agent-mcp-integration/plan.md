# Implementation Plan: AI Agent + MCP Server Integration

**Branch**: `001-ai-agent-mcp-integration` | **Date**: 2026-01-12 | **Spec**: [specs/001-ai-agent-mcp-integration/spec.md](../001-ai-agent-mcp-integration/spec.md)

**Input**: Feature specification from `/specs/001-ai-agent-mcp-integration/spec.md`

**Note**: This template is filled in by the `/sp.plan` command. See `.specify/templates/commands/plan.md` for the execution workflow.

## Summary

Implementation of an AI agent and MCP server to provide natural language processing for todo operations. The AI agent will use OpenAI Agents SDK with Gemini AI integration, and the MCP server will act as a bridge between the AI agent and existing FastAPI Todo APIs. The system will maintain all Phase II functionality while adding intelligent task management capabilities through natural language commands.

## Technical Context

**Language/Version**: Python 3.13 or higher, JavaScript/TypeScript for Next.js frontend
**Primary Dependencies**: OpenAI Agents SDK, FastAPI, uv, SQLite, Next.js
**Storage**: PostgreSQL (existing Phase II), SQLite (AI agent operations)
**Testing**: pytest for backend, Jest for frontend
**Target Platform**: Web application with Next.js frontend and Python FastAPI backend
**Project Type**: Full-stack web application with AI integration
**Performance Goals**: AI agent response time under 5 seconds, 95% task operation success rate
**Constraints**: <200ms p95 for API calls, user data isolation maintained, 99% Phase II feature availability
**Scale/Scope**: Individual user task management, no multi-tenancy beyond existing user isolation

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

- All code MUST be generated by Claude Code (No manual coding)
- All functionality MUST be defined in specifications before implementation
- Specs are the single source of truth
- UV MUST be used for Python project and dependency management
- Python version MUST be 3.13 or higher
- OpenAI Agents SDK MUST be used for AI agent implementation
- MCP Server MUST act as the sole bridge between AI agent and backend
- SQLite MUST be used as file-based database for AI operations
- Gemini AI MUST be configured using OpenAI-compatible API
- Phase II code MUST NOT be deleted or modified
- AI agent MUST NOT engage in general chat conversations
- AI agent MUST NOT access database directly
- AI agent MUST ONLY perform Todo-related actions
- JWT tokens MUST be required for all AI agent requests
- MCP Server MUST NOT operate without valid JWT token
- MCP Server MUST enforce strict user_id boundaries

## Project Structure

### Documentation (this feature)

```text
specs/001-ai-agent-mcp-integration/
├── plan.md              # This file (/sp.plan command output)
├── research.md          # Phase 0 output (/sp.plan command)
├── data-model.md        # Phase 1 output (/sp.plan command)
├── quickstart.md        # Phase 1 output (/sp.plan command)
├── contracts/           # Phase 1 output (/sp.plan command)
└── tasks.md             # Phase 2 output (/sp.tasks command - NOT created by /sp.plan)
```

### Source Code (repository root)

```text
backend/
├── src/
│   ├── models/
│   ├── services/
│   ├── api/
│   ├── agents/          # AI agent implementation
│   │   ├── __init__.py
│   │   ├── ai_agent.py  # Main AI agent implementation
│   │   ├── mcp_server.py # MCP server implementation
│   │   └── tools.py     # MCP tools definitions
│   └── main.py
└── tests/

frontend/
├── src/
│   ├── components/
│   │   └── ai-agent/    # AI agent UI components
│   │       ├── AgentIcon.tsx
│   │       └── AgentPanel.tsx
│   ├── pages/
│   │   └── dashboard/
│   │       └── index.tsx # With AI agent integration
│   ├── services/
│   │   └── ai-agent-service.ts
│   └── lib/
└── tests/

database/
├── ai_agent_db.sqlite   # SQLite file for AI agent operations
└── migrations/
```

**Structure Decision**: Full-stack web application with separate backend and frontend directories, with AI agent functionality integrated into existing architecture while maintaining Phase II functionality.

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

| Violation | Why Needed | Simpler Alternative Rejected Because |
|-----------|------------|-------------------------------------|
| None | None | None |

## Phase 0: Research

### Research Tasks

1. **AI Agent Implementation Research**
   - Decision: Use OpenAI Agents SDK with Gemini AI integration
   - Rationale: Aligns with constitution requirement for OpenAI SDK and Gemini AI
   - Alternatives considered: LangChain, custom NLP solutions (rejected for complexity)

2. **MCP Server Architecture Research**
   - Decision: Implement MCP server as a bridge between AI agent and FastAPI APIs
   - Rationale: Required by constitution to avoid direct database access
   - Alternatives considered: Direct API calls from agent (rejected for security)

3. **SQLite Integration Research**
   - Decision: Use file-based SQLite for AI agent operations
   - Rationale: Constitution mandates SQLite for AI operations
   - Alternatives considered: In-memory storage (rejected for persistence needs)

4. **JWT Token Handling Research**
   - Decision: Validate JWT tokens in MCP server for each request
   - Rationale: Security requirement from constitution
   - Alternatives considered: Session-based auth (rejected for consistency)

5. **Frontend Integration Research**
   - Decision: Add AI agent icon to dashboard with panel overlay
   - Rationale: Matches UI requirements in constitution
   - Alternatives considered: Separate AI page (rejected for UX disruption)

## Phase 1: Design & Contracts

### Data Model Design

**AI Agent Session Entity**:
- session_id (UUID, PK)
- user_id (Integer, FK to User)
- conversation_history (JSON)
- created_at (DateTime)
- last_interaction_at (DateTime)

**User Request Entity**:
- request_id (UUID, PK)
- session_id (UUID, FK to Session)
- content (Text)
- timestamp (DateTime)

**MCP Tool Call Entity**:
- call_id (UUID, PK)
- session_id (UUID, FK to Session)
- tool_name (String)
- parameters (JSON)
- result (JSON)
- timestamp (DateTime)

**Agent Response Entity**:
- response_id (UUID, PK)
- session_id (UUID, FK to Session)
- content (Text)
- timestamp (DateTime)

### API Contracts

#### AI Agent Endpoint
```
POST /api/ai-agent/message
Headers: Authorization: Bearer <jwt_token>
Body: { "message": "natural language command" }
Response: { "response": "ai response", "action_result": {} }
```

#### MCP Tools (Internal)
- create_task: Maps to existing POST /api/{user_id}/tasks
- list_tasks: Maps to existing GET /api/{user_id}/tasks
- update_task: Maps to existing PUT /api/{user_id}/tasks/{id}
- delete_task: Maps to existing DELETE /api/{user_id}/tasks/{id}
- complete_task: Maps to existing PATCH /api/{user_id}/tasks/{id}/complete

### Quickstart Guide

1. Clone the repository
2. Install Python dependencies with `uv`
3. Set up environment variables (GEMINI_API_KEY)
4. Run the backend: `python -m backend.src.main`
5. Run the frontend: `npm run dev` in frontend directory
6. Access the application at http://localhost:3000
7. Log in and use the AI agent icon on the dashboard

### Agent Context Update

The agent context has been updated with the new technologies:
- OpenAI Agents SDK
- MCP Server patterns
- Gemini AI integration
- SQLite for AI operations

## Phase 2: Planning

The detailed implementation tasks will be generated in the tasks.md file using the `/sp.tasks` command. The plan includes setting up the AI agent, MCP server, database integration, frontend components, and ensuring all constitutional requirements are met.

Re-evaluation of Constitution Check after design: All requirements satisfied, no violations identified.